# These functions need to be changed so that they take a sub-section of a tree specified by node.

# PS also modify the other local rates options to be able to be rescaled. To do this take the sum of the branch lengths in the clade before
# transformation, and divide it by the sum of the branch lengths in the clade after transformation, and then this gives a multiplier which
# the new branch lengths are timesed by to normalise.




heights.phylo=function(x){
    phy=x
	phy <- reorder(phy, "postorder")
	n <- length(phy$tip.label)
	n.node <- phy$Nnode
	xx <- numeric(n + n.node)
	for (i in nrow(phy$edge):1) xx[phy$edge[i, 2]] <- xx[phy$edge[i, 1]] + phy$edge.length[i]
	root = ifelse(is.null(phy$root.edge), 0, phy$root.edge)
	labs = c(phy$tip.label, phy$node.label)
	depth = max(xx)
	tt = depth - xx
	idx = 1:length(tt)
	dd = phy$edge.length[idx]
	mm = match(1:length(tt), c(phy$edge[, 2], Ntip(phy) + 1))
	dd = c(phy$edge.length, root)[mm]
	ss = tt + dd
	res = cbind(ss, tt)
	rownames(res) = idx
	colnames(res) = c("start", "end")
	res = data.frame(res)
	res
}


.eb.phylo=function(phy){
	
	# i think i can get away with doing the previous function for the full tree, then just sectioning out the heights that I need.
	# Each height is labelled in it's row name with the node, and then a start and an end.
	# It's more simple to use nodeHeights from phytools - but first work out what order they come out in, and also add a root, so that
	# the following code is functioning the same.
	
	
	ht = heights.phylo(phy)
	N = Ntip(phy)
	# Find the age of the tree.
	Tmax = ht$start[N+1]
	mm = match(1:nrow(ht), phy$edge[,2])
	ht$t1 = Tmax - ht$end[phy$edge[mm,1]]
	ht$t2 = ht$start - ht$end + ht$t1
	
	z=function(a, sigsq=1){
		if(a==0) return(phy)
		bl = (exp(a*ht$t2)-exp(a*ht$t1))/(a)
		phy$edge.length=bl[phy$edge[,2]]
        phy$edge.length=phy$edge.length*sigsq
		phy
	}
	attr(z,"argn")=c("a", "sigsq")
	return(z)
}




# This is the old geiger function for, I think, the same thing... OK - they are basically doing the exact same thing, except 
# this one does it in a simpler, more readable way.

exponentialchangeTree<-function (phy, endRate=NULL, a=NULL) 
{
	

    if(is.null(a)&&is.null(endRate))
    	stop("Must supply either endRate or a")
    	
   	times <- branching.times(phy)
    d<-max(times)
    if(is.null(a))
 	   a<-log(endRate)/d
 	if(a==0) return(phy)   
    names(times) <- (as.numeric(names(times)))
    for (i in 1:length(phy$edge.length)) {
        bl <- phy$edge.length[i]
        age = times[which(names(times) == phy$edge[i, 1])]
        t1 = max(times) - age
        t2 = t1+bl
        phy$edge.length[i] = (exp(a*t2)-exp(a*t1))/(a)
    }
    phy
}

localEB <- function(tree, node, a) {
  descs <- getDescs(tree, node)
  descs <- c(descs, node)
  trans.edges <- which(tree$edge[ ,1] %in% descs & tree$edge[ ,1] > length(tree$tip.label))
  bls <- tree$edge.length[trans.edges]
  times <- branching.times(tree)
  times <- times[names(times) %in% descs]
  maxt <- max(times)
  for (i in 1:length(trans.edges)) {
  
  }
  
  
  
}


# the old deltatree


deltaTree <- function (phy, delta, rescale = T) 
{
    tmp <- as.numeric(phy$edge)
    times <- branching.times(phy)
    original.rtt.length <- max(times)
    times = max(times) - times
    max(times)
    tips <- length(phy$tip.label)
    res <- phy
    for (i in 1:length(phy$edge.length)) {
        bl <- phy$edge.length[i]
        age = times[phy$edge[i, 1] - tips]
        res$edge.length[i] <- (age + bl)^delta - age^delta
    }
    if (rescale == T) 
        res <- rescaleTree(res, original.rtt.length)
    res
}


### and mine

localDelta <- function(tree, node, delta) {
  descs <- getDescs(tree, node)
  descs <- c(descs, node)
  trans.edges <- which(tree$edge[ ,1] %in% descs & tree$edge[ ,1] > length(tree$tip.label))
  trans.edges <- c(trans.edges, which(tree$edge[ ,2] == node))
  descs <- c(descs, tree$edge[which(tree$edge[ ,2] == node), 1])
  bls <- tree$edge.length[trans.edges]
  times <- branching.times(tree)
  times <- times[names(times) %in% descs]
  original.length <- max(times)
  times <- max(times) - times
  res <- tree
  
  for (i in 1:length(trans.edges)) {
    bl <- tree$edge.length[trans.edges[i]]
    age <- times[names(times) %in% tree$edge[trans.edges][i]]
    res$edge.length[trans.edges[i]] <- (age + bl) ^ delta - age ^ delta
  }
  
  return(res)
}






