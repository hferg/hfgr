### Work out how to transform a tree by a local lambda.

# Note - BayesTrees can be used to visually compare the outputs of this process

# 1) Load tree sample from simulation, and make a small tree of 30 taxa.


# 2) Get the vcv matrix of the tree.
#   Look at the lambda.transform function from phytools to get an idea of this - Liam's code is more transparent that the ocde in geiger.

# 3) Here is lambdaTree from Liam Revell's blog
# I think this is a starting place from which to work on just changing a sub-section of the tree.

lambdaTree<-function(tree,lambda){
  # This is extracting the tips (I am pretty sure, since edges are numbered from the tips, and it selects all edges with a number greater
  # than the number of tips.
  ii<-which(tree$edge[,2]>length(tree$tip.label))
  # This is extracting the node heights from the tree using a built-in function from phytools.
  H1<-nodeHeights(tree)
  # Now the internal edges (not tips) are multipled by lambda. This shortens the edges, and brings the tips in toward the past.
  tree$edge.length[ii]<-lambda*tree$edge.length[ii]
  # Get the node heights from the tree now that the edge lengths have been multiplied by lambda.
  H2<-nodeHeights(tree)
  # Now the tips are brought back to the present, and the tree has been transformed by lambda
  tree$edge.length[-ii]<-tree$edge.length[-ii]+     H1[-ii,2]-H2[-ii,2]
  tree
}

# This approach is fully legit - the tree is transformed according to lambda, and if you need a vcv matrix it is the same when
# calculated from the transformed tree.

# First make a pretty small tree, just sample 40 taxa from the 200 taxa tree.

treesm <- drop.tip(trees[[1]], sample(length(trees[[1]]$tip.label), 160))

# compare the vcv matrices from the geiger approach, and this approach. - close enough

lam <- rescale(treesm, "lambda")
tree.g <- lam(0.5)
tree.p <- lambdaTree(treesm, 0.5)

vcv.phylo(tree.g) == vcv.phylo(tree.p)

vcv.phylo(tree.g) - vcv.phylo(tree.p)


# Now I need to work out how to apply that to just a sub-set of the branch lengths.

# Start by specifying a clade/node. If clade, get the MRCA, which will be a node.

# use getMRCA from APE. It takes either a vector of tip names.




# this might find all the descendant nodes, and then I think that the second column of the edges will do it?
# So here is the lowdown. In edge column one is ancestor and column 2 is descendant, and the edge links those two nodes.
# Branch lengths are stored in a vecotor that correspond to each row of the edges object.


localLambda <- function(tree, node) {
  if (is.vector(node)) {
    node <- getMRCA(tree, node)
  }
}




descNodes<-Descendants(tree2,node,"all")


getDescendants<-function(tree,node,curr=NULL){
  if(is.null(curr)) curr<-vector()
  
  daughters<-tree$edge[which(tree$edge[,1]==node),2]
  
  curr<-c(curr,daughters)
  
  w<-which(daughters>=length(tree$tip))
  
  if(length(w)>0) for(i in 1:length(w))
    curr<-getDescendants(tree,daughters[w[i]],curr)
  return(curr)
}



### Non-annotated function

lambdaTree<-function(tree,lambda){
  ii<-which(tree$edge[,2]>length(tree$tip.label))
  H1<-nodeHeights(tree)
  tree$edge.length[ii]<-lambda*tree$edge.length[ii]
  H2<-nodeHeights(tree)
  tree$edge.length[-ii]<-tree$edge.length[-ii]+     H1[-ii,2]-H2[-ii,2]
  tree
}


