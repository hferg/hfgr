### Work out how to transform a tree by a local lambda.

# Note - BayesTrees can be used to visually compare the outputs of this process

# 1) Load tree sample from simulation, and make a small tree of 30 taxa.


# 2) Get the vcv matrix of the tree.
#   Look at the lambda.transform function from phytools to get an idea of this - Liam's code is more transparent that the ocde in geiger.

# here it is

function (lambda, C) 
{
    if (lambda == 1) 
        return(C)
    else {
        V <- diag(diag(C))
        C <- C - V
        C.lambda <- (V + lambda * C)
        return(C.lambda)
    }
}

# and it is used in phyl.pca - which is here.

function (tree, Y, method = "BM", mode = "cov", ...) 
{
    if (hasArg(opt)) 
        opt <- list(...)$opt
    else opt <- "ML"
    if (class(tree) != "phylo") 
        stop("tree must be an object of class 'phylo.'")
    if (length(strsplit(mode, split = "")[[1]]) <= 2) {
        message(paste("mode = '", mode, "' not a valid option; setting mode = 'cov'", 
            sep = ""))
        mode = "cov"
    }
    if (all(strsplit(mode, split = "")[[1]] == strsplit("correlation", 
        split = "")[[1]][1:length(strsplit(mode, split = "")[[1]])])) 
        mode = "corr"
    else if (all(strsplit(mode, split = "")[[1]] == strsplit("covariance", 
        split = "")[[1]][1:length(strsplit(mode, split = "")[[1]])])) 
        mode = "cov"
    else {
        message(paste("mode = '", mode, "' not a valid option; setting mode = 'cov'", 
            sep = ""))
        mode = "cov"
    }
    n <- nrow(Y)
    m <- ncol(Y)
    if (n > length(tree$tip)) 
        stop("number of rows in Y cannot be greater than number of taxa in your tree")
    Y <- as.matrix(Y)
    if (is.null(rownames(Y))) {
        if (nrow(Y) == n) {
            print("Y has no names. function will assume that the row order of Y matches tree$tip.label")
            rownames(Y) <- tree$tip.label
        }
        else stop("Y has no names and does not have the same number of rows as tips in tree")
    }
    else if (length(setdiff(rownames(Y), tree$tip.label)) != 
        0) 
        stop("Y has rownames, but some rownames of Y not found in tree")
    C <- vcv.phylo(tree)[rownames(Y), rownames(Y)]
    if (method == "BM") {
        temp <- phyl.vcv(Y, C, 1)
        V <- temp$R
        a <- t(temp$alpha)
        C <- temp$C
    }
    else if (method == "lambda") {
        if (opt == "ML") 
            temp <- optimize(f = likMlambda, interval = c(0, 
                maxLambda(tree)), X = Y, C = C, maximum = TRUE)
        else if (opt == "REML") 
            temp <- optimize(f = remlMlambda, interval = c(0, 
                maxLambda(tree)), tree = tree, X = Y, maximum = TRUE)
        lambda <- temp$maximum
        logL <- as.numeric(temp$objective)
        temp <- phyl.vcv(Y, C, lambda)
        V <- temp$R
        a <- t(temp$alpha)
        C <- temp$C
    }
    invC <- solve(C)
    if (mode == "corr") {
        Y = Y/matrix(rep(sqrt(diag(V)), n), n, m, byrow = T)
        V = V/(sqrt(diag(V)) %*% t(sqrt(diag(V))))
        a <- matrix(colSums(invC %*% Y)/sum(invC), m, 1)
    }
    es = eigen(V)
    result <- list()
    result$Eval <- diag(es$values)
    result$Evec <- es$vectors
    dimnames(result$Eval) <- list(paste("PC", 1:ncol(Y), sep = ""), 
        paste("PC", 1:ncol(Y), sep = ""))
    dimnames(result$Evec) <- list(colnames(Y), paste("PC", 1:ncol(Y), 
        sep = ""))
    A <- matrix(rep(a, n), n, m, byrow = T)
    result$S <- (Y - A) %*% result$Evec
    Ccv <- t(Y - A) %*% invC %*% result$S/(n - 1)
    result$L <- matrix(, m, m, dimnames = list(colnames(Y), paste("PC", 
        1:ncol(Y), sep = "")))
    for (i in 1:m) for (j in 1:m) result$L[i, j] <- Ccv[i, j]/sqrt(V[i, 
        i] * result$Eval[j, j])
    if (method == "lambda") {
        result$lambda <- lambda
        result$logL.lambda <- logL
    }
    class(result) <- "phyl.pca"
    return(result)
}



# 3) fuck with it, and look at the outputs.
