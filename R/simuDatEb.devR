#' simuDatEb
#'
#' Simulate data over a phylogeny, or sub section of a phylogeny, in order to reflect variable rates.
#' Based on adding a constant to the tip data branch by branch and weighting by branch length and does
#' not need to stretch the phylogeny.

#' @param tree
#' @param node
#' @param a The number of half lives for the decay to take place over. Essentially a high number means the rate decays rapidly, and a low one means it decays slowly. This is used rather than a rate parameter, since decay is relative to branch lengths, but half lives are not.
#' @param sig The standard deviation of the random component of the BM simulation. NOT sigma squared.
#' @param dat If you want to use some data you already have and change it this way, put it here.
#' @export

simuDatRate <- function(tree, node, sig, a, dat = NULL) {
  
  if (isDefined(dat)) {
    dat <- dat
  } else {
    dat <- rTraitCont(tree, model = "BM", sigma = sig)
  }
  
  transdat <- dat  
  # So, branches deeper in the tree need to be scaled more than those recently, which is to say that the amount to add/subtract is larger.
  # That means that the age of the clade needs to be found, and then the transformation scaled according to that age.
  
  # Alternatively find out the age of the branch leading to the deepest node int he clade to be scaled, and have that as a zero point,
  # and then everything gets an age relative to zero - then the bigger that age, the lest it is scaled by.
  
  
  
  
  
  

  descs <- c(getDescs(tree, node), node)
  internal <- descs[descs > length(tree$tip.label)]
  tips <- descs[descs < length(tree$tip.label)]
  edges <- tree$edge[tree$edge[ ,2] %in% c(internal, tips), ]
  bls <- tree$edge.length[tree$edge[ ,2] %in% c(internal, tips)]
  
  for (i in 1:nrow(edges)) {
    tps <- getDescs(tree, edges[i, 2])
    tps <- tps[tps < length(tree$tip.label)]
    num <- sample(2, 1)
    
    if (num == 1) {
      transdat[tps] <- transdat[tps] + (bls[i] * (a * sig))
    } else {
      transdat[tps] <- transdat[tps] - (bls[i] * (a * sig))
    }
  }

  res <- list(original = dat, transformed = transdat)
  return(res)
}




####################################################################################################################################################


setwd("Documents/hfg_work/20150605_proper_datasim/analysis")
tree <- read.nexus("tree1.trees")

node <- 256
sig <- 1

# Get all descendents from that node.

descs <- getDescs(tree, node)

# Now get each of those descendents that's an internal node, find it's age relative to the root, and then standardise it so that oldest is
# zero, and they get bigger from there.

internal <- descs[descs >= length(tree$tip.label)]

# Now find the descenent tips for each of those nodes, and add to those tips some number determined by the half lives, and a scale given
# by the age of that node such that older nodes (closer to the new zero point) have more added.

# Here, instead of using bl to satandardise, I need to use height, since that is what is more important.

times <- branching.times(tree)
heights <- nodeHeights(tree)
heights <- heights[tree$edge[ ,2] %in% descs]




transnode <- nodeheight(tree, node)


# Approach 1 - same as normal rates, but instead of multiplying by branch length, use that for the powers.

  if (isDefined(dat)) {
    dat <- dat
  } else {
    dat <- rTraitCont(tree, model = "BM", sigma = sig)
  }
  
  transdat <- dat  


  descs <- c(getDescs(tree, node), node)
  internal <- descs[descs > length(tree$tip.label)]
  tips <- descs[descs < length(tree$tip.label)]
  edges <- tree$edge[tree$edge[ ,2] %in% c(internal, tips), ]
  bls <- tree$edge.length[tree$edge[ ,2] %in% c(internal, tips)]
  
  for (i in 1:nrow(edges)) {
    tps <- getDescs(tree, edges[i, 2])
    tps <- tps[tps < length(tree$tip.label)]
    num <- sample(2, 1)
    
    if (num == 1) {
      transdat[tps] <- transdat[tps] + (bls[i] * (a * sig))
    } else {
      transdat[tps] <- transdat[tps] - (bls[i] * (a * sig))
    }
  }

  res <- list(original = dat, transformed = transdat)
  return(res)



